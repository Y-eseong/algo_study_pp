import java.util.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
	
	//문제에서 배열 크기에 필요한 N, M을 미리 준비. 클래스 내부 어디에서든 쓸 수 있게.
	static int N, M;
	
	//상하좌우로 이동할 수 범위. 세로축이 x, 가로축이 y
	static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};
    
    //탐색을 할 지도 배열. 배열에 덮어 쓸 예정이기 때문에 별도의 배열은 생성하지 않는다. 즉, 원본에 그대로 대입
    static int[][] map;
    
    //방문여부를 확인할 수 있는 배열. 기본값이 false로 되어있고, 방문했을 경우 true로 전환
    static boolean[][] visited;

	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		
		//배열의 길이를 입력받고
		//String a = in.readLine();
		//String[] u = a.split(" ");
		String[] u = in.readLine().split(" ");
		
		//각각 N과 M으로 나눠서 작성
		N = Integer.parseInt(u[0]);
		M = Integer.parseInt(u[1]);
		
		//입력받은 값의 크기만큼 지도(map)과 방문여부 배열을 생성
		map = new int[N][M];
        visited = new boolean[N][M];
		
        //for문을 통해 값을 입력받아, map을 채운다.
		for (int i = 0; i < N; i++) {
			String b = in.readLine();
			String[] c = b.split("");
			
			for (int j = 0; j < M; j++) {
				map[i][j] = Integer.parseInt(c[j]);
			}
			
		}
		//여기까지 지도를 입력받았고
		
		//bfs 알고리즘 시작
		bfs(0,0);

		//도착지에 온 값들 중 가장 최단 거리를 구하는 것. 이미 먼저 도착한 값이 있다면 방문여부에 체크되어 갱신이 불가능해져, 그 이후에 도착한 값은 무시해도 된다.
		//시작이 0,0이었고, N과 M으로 가야하며 그 값에 지정되어있는 거리를 추출
		System.out.println(map[N-1][M-1]);
		
	}
	
	public static void bfs(int x, int y) {
		//큐 생성
		Queue<int[]> queue = new LinkedList<>();
		//큐에 첫 번째 위치 즉, 해당 알고리즘에서는 0,0을 각각 투입
		queue.offer(new int[] {x,y});
		//시작하는 위치이자 방문을 했다고 판단하여 true로 전환
		visited[x][y] = true;
		
		
		//while문. isEmpty는 값이 없을 경우에 true를 반환하나, !를 붙여서 값이 있다면 true를 반환한다. 즉, 큐에 잔여 값이 없어야 while문이 종료된다.
		while(!queue.isEmpty()) {
			//poll. 큐 맨 앞 값을 꺼내오고 now 배열에 할당하며, 원본값은 삭제
			int[] now = queue.poll();
			
			//이제 4방향을 찾아야 한다. 물결처럼, 4방향으로 퍼져나간다고 생각하자.
			for(int i = 0; i < 4; i++) {
				//nx와 ny는 기족 즉, now의 위치에 상하좌우 값을 더한, 미리 예측해보는 값이다. 이걸 안하면 배열 밖으로 터져나가서 문제된다.
				int nx = now[0]+dx[i];
				int ny = now[1]+dy[i];
				
				//만일 nx ny의 값이 배열 밖으로 터져나가면 밑에 코드들을 실행하지 않고
				if (nx < 0 || ny < 0 || nx >= N || ny >= M) {continue;}
				//map에서 0 즉, 벽일 경우 혹은 방문 여부에서 true여서 미리 방문할 경우 밑의 코드들은 실행하지 않는다
				if (map[nx][ny] == 0 || visited[nx][ny]) {continue;}
				
				//위의 2개의 if문에서 걸러졌기 때문에, 배열이 터지지도 않았고 방문한 적이 없는 값이 된다. 따라서, 새롭게 갈 수 있는 위치이다. 그렇기에 큐에 담아둔다.
				queue.offer(new int[] {nx, ny});
				//이제 위에서 큐에 담았기에 방문한 것으로 간주하여, 방문여부를 true로 전환해둔다.
				visited[nx][ny] = true;
				//다음 위치로 이동할 경우에는 기존에 있던 즉, now의 위치에 있는 값에다 1을 더한 즉, 걸어온 위치에다가 1을 더해 그 값을 배정한다. 어차피 벽인 0이냐 아니냐를 보기에 원본 값이 변형되더라도 문제 없다.
				//또한 시작 위치가 1이었기 때문에, 그 다음 값들은 1씩 더해져서 0,0의 위치인 1 다음에 상하좌우로 가는 이들은 모두 2가 된다.
				map[nx][ny] = map[now[0]][now[1]] + 1;
				
				//즉, 위의 2줄 코드는 큐에 담길 즉, 다음에 갈 위치를 방문 확인 및 거리 계산을 사전에 해두는 것이다.
				
			}
			
		}
		
	}
	
}
