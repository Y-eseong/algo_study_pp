import java.util.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
	static int N;
	
	static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};
	
    static int[][] map;
    static boolean[][] visited;
    static String answer = "";
    
    
    public static void main(String[] args) throws IOException {
    	List<Integer> answerList = new ArrayList<>();
    	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    	
    	N = Integer.parseInt(in.readLine());
    	
    	map = new int[N][N];
    	visited = new boolean[N][N];
    	
    	for (int i = 0; i < N; i++) {
    		//문자열 입력받고
    		String x = in.readLine();
    		String[] arr = x.split("");
    		
    		for (int j = 0; j < N; j++) {
    			map[i][j] = Integer.parseInt(arr[j]);
    		}
    	}
    	//System.out.println(Arrays.deepToString(map));
    	//여기까지 단지 구현 완료
    	
    	for (int i = 0; i < N; i++) {
    		for (int j = 0; j < N; j++) {
    			if (map[i][j] == 1 && visited[i][j] != true) {
    				answerList.add(bfs(i, j));
    			}
    		}
    	}
    	
    	Collections.sort(answerList);
    	
    	System.out.println(answerList.size());
    	
    	for (int i : answerList) {
    		System.out.println(i);
    	}
    	
    }
    
    
    public static int bfs(int x, int y) {
    	Queue<int[]> queue = new LinkedList<>();
    	queue.offer(new int[] {x,y});
    	visited[x][y] = true;
    	int find = 1;
    	
		while(!queue.isEmpty()) {
			//poll. 큐 맨 앞 값을 꺼내오고 now 배열에 할당하며, 원본값은 삭제
			int[] now = queue.poll();
			
			//이제 4방향을 찾아야 한다. 물결처럼, 4방향으로 퍼져나간다고 생각하자.
			for(int i = 0; i < 4; i++) {
				//nx와 ny는 기족 즉, now의 위치에 상하좌우 값을 더한, 미리 예측해보는 값이다. 이걸 안하면 배열 밖으로 터져나가서 문제된다.
				int nx = now[0]+dx[i];
				int ny = now[1]+dy[i];
				
				//만일 nx ny의 값이 배열 밖으로 터져나가면 밑에 코드들을 실행하지 않고
				if (nx < 0 || ny < 0 || nx >= N || ny >= N) {continue;}
				//map에서 0 즉, 벽일 경우 혹은 방문 여부에서 true여서 미리 방문할 경우 밑의 코드들은 실행하지 않는다
				if (map[nx][ny] == 0 || visited[nx][ny]) {continue;}
				
				//위의 2개의 if문에서 걸러졌기 때문에, 배열이 터지지도 않았고 방문한 적이 없는 값이 된다. 따라서, 새롭게 갈 수 있는 위치이다. 그렇기에 큐에 담아둔다.
				queue.offer(new int[] {nx, ny});
				//이제 위에서 큐에 담았기에 방문한 것으로 간주하여, 방문여부를 true로 전환해둔다.
				visited[nx][ny] = true;
				//find에 방문했으니 추가
				find++;
				
				
			}
    	
    	
    	
    }
		
		return find;
}
    
}
